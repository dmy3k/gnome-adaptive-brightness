/**
 * Tests for KeyboardBacklightDbus
 * Tests the low-level D-Bus interface for keyboard backlight control
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';

// Mock proxy instance with methods generated by makeProxyWrapper
const mockProxy = {
  GetMaxBrightnessAsync: jest.fn(),
  GetBrightnessAsync: jest.fn(),
  SetBrightnessAsync: jest.fn(),
  connectSignal: jest.fn().mockReturnValue(1),
  disconnect: jest.fn(),
  disconnectSignal: jest.fn(),
};

// Mock the makeProxyWrapper to return a constructor function
let mockProxyConstructor;
const mockMakeProxyWrapper = jest.fn((xml) => {
  mockProxyConstructor = jest.fn((bus, busName, objectPath, callback) => {
    process.nextTick(() => callback(mockProxy, null));
  });
  return mockProxyConstructor;
});

const mockGio = {
  DBus: {
    system: {},
  },
  DBusProxy: {
    makeProxyWrapper: mockMakeProxyWrapper,
  },
};

jest.unstable_mockModule('gi://Gio', () => ({ default: mockGio }));

const { KeyboardBacklightDbus } = await import('../lib/KeyboardBacklightDbus.js');

describe('KeyboardBacklightDbus', () => {
  let dbus;
  let brightnessSignalCallback;

  beforeEach(() => {
    jest.clearAllMocks();

    mockProxy.GetMaxBrightnessAsync.mockImplementation((callback) => {
      process.nextTick(() => callback(2, null));
    });

    mockProxy.GetBrightnessAsync.mockImplementation((callback) => {
      process.nextTick(() => callback(0, null));
    });

    mockProxy.SetBrightnessAsync.mockImplementation((value, callback) => {
      process.nextTick(() => callback(null, null));
    });

    mockProxy.connectSignal.mockImplementation((signalName, callback) => {
      if (signalName === 'BrightnessChanged') {
        brightnessSignalCallback = callback;
      }
      return 1;
    });

    dbus = new KeyboardBacklightDbus();
  });

  describe('connect()', () => {
    it('should connect to UPower keyboard backlight service', async () => {
      await dbus.connect();

      expect(mockProxyConstructor).toHaveBeenCalledWith(
        mockGio.DBus.system,
        'org.freedesktop.UPower',
        '/org/freedesktop/UPower/KbdBacklight',
        expect.any(Function)
      );
    });

    it('should fetch max and current brightness after connection', async () => {
      await dbus.connect();

      expect(mockProxy.GetMaxBrightnessAsync).toHaveBeenCalled();
      expect(mockProxy.GetBrightnessAsync).toHaveBeenCalled();
      expect(dbus._maxBrightness).toBe(2);
      expect(dbus._currentBrightness).toBe(0);
    });

    it('should subscribe to BrightnessChanged signal', async () => {
      await dbus.connect();

      expect(mockProxy.connectSignal).toHaveBeenCalledWith(
        'BrightnessChanged',
        expect.any(Function)
      );
      expect(dbus._signalId).toBe(1);
    });

    it('should update internal brightness state on signal', async () => {
      await dbus.connect();

      brightnessSignalCallback(mockProxy, 'sender', [1]);

      expect(dbus._currentBrightness).toBe(1);
    });
  });

  describe('isAvailable', () => {
    it('should return true when max brightness is greater than 0', async () => {
      await dbus.connect();

      expect(dbus.isAvailable).toBe(true);
    });

    it('should return false when max brightness is 0', async () => {
      mockProxy.GetMaxBrightnessAsync.mockImplementation((callback) => {
        process.nextTick(() => callback(0, null));
      });

      await dbus.connect();

      expect(dbus.isAvailable).toBe(false);
    });

    it('should return false before connection', () => {
      expect(dbus.isAvailable).toBe(false);
    });
  });

  describe('isEnabled', () => {
    beforeEach(async () => {
      await dbus.connect();
    });

    it('should return false when brightness is 0', () => {
      expect(dbus.isEnabled).toBe(false);
    });

    it('should return true when brightness is greater than 0', () => {
      dbus._currentBrightness = 1;
      expect(dbus.isEnabled).toBe(true);
    });
  });

  describe('setBrightness()', () => {
    beforeEach(async () => {
      await dbus.connect();
      jest.clearAllMocks();
    });

    it('should set brightness via D-Bus', async () => {
      await dbus.setBrightness(1);

      expect(mockProxy.SetBrightnessAsync).toHaveBeenCalledWith(1, expect.any(Function));
    });

    it('should clamp brightness to max value', async () => {
      await dbus.setBrightness(999);

      expect(mockProxy.SetBrightnessAsync).toHaveBeenCalledWith(2, expect.any(Function));
    });

    it('should clamp brightness to minimum of 0', async () => {
      dbus._currentBrightness = 1;

      await dbus.setBrightness(-5);

      expect(mockProxy.SetBrightnessAsync).toHaveBeenCalledWith(0, expect.any(Function));
    });

    it('should round fractional brightness values', async () => {
      await dbus.setBrightness(1.7);

      expect(mockProxy.SetBrightnessAsync).toHaveBeenCalledWith(2, expect.any(Function));
    });

    it('should skip D-Bus call if brightness has not changed', async () => {
      dbus._currentBrightness = 1;

      await dbus.setBrightness(1);

      expect(mockProxy.SetBrightnessAsync).not.toHaveBeenCalled();
    });

    it('should update internal state after successful D-Bus call', async () => {
      await dbus.setBrightness(2);

      expect(dbus._currentBrightness).toBe(2);
    });

    it('should throw error if not connected', async () => {
      const newDbus = new KeyboardBacklightDbus();

      await expect(newDbus.setBrightness(1)).rejects.toThrow('D-Bus proxy not connected');
    });

    it('should warn and return early if keyboard backlight not available', async () => {
      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
      dbus._maxBrightness = 0;

      await dbus.setBrightness(1);

      expect(consoleWarnSpy).toHaveBeenCalledWith('Keyboard backlight not available');
      expect(mockProxy.SetBrightnessAsync).not.toHaveBeenCalled();

      consoleWarnSpy.mockRestore();
    });

    it('should propagate D-Bus errors', async () => {
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
      mockProxy.SetBrightnessAsync.mockImplementation((value, callback) => {
        process.nextTick(() => callback(null, new Error('D-Bus error')));
      });

      await expect(dbus.setBrightness(1)).rejects.toThrow('D-Bus error');

      consoleErrorSpy.mockRestore();
    });
  });

  describe('destroy()', () => {
    it('should disconnect signal handler and clean up', async () => {
      await dbus.connect();

      dbus.destroy();

      expect(mockProxy.disconnectSignal).toHaveBeenCalledWith(1);
      expect(dbus._proxy).toBeNull();
      expect(dbus._maxBrightness).toBeNull();
      expect(dbus._currentBrightness).toBeNull();
      expect(dbus._signalId).toBeNull();
    });

    it('should handle destroy before connection', () => {
      expect(() => dbus.destroy()).not.toThrow();
    });

    it('should handle multiple destroy calls', async () => {
      await dbus.connect();
      dbus.destroy();

      expect(() => dbus.destroy()).not.toThrow();
    });
  });
});
