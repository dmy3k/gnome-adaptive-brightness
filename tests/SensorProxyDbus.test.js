/**
 * Tests for SensorProxyDbus
 * Tests the low-level D-Bus interface for sensor proxy communication
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';

// Mock proxy instance with properties and methods generated by makeProxyWrapper
const mockProxy = {
  ClaimLightAsync: jest.fn(),
  ReleaseLightAsync: jest.fn(),
  LightLevel: null,
  LightLevelUnit: 'lux',
  HasAmbientLight: null,
  connect: jest.fn().mockReturnValue(1),
  disconnect: jest.fn(),
  emit: jest.fn(),
};

// Create the proxy constructor once and reuse it
const mockProxyConstructor = jest.fn((bus, busName, objectPath, callback) => {
  process.nextTick(() => callback(mockProxy, null));
});

// Mock the makeProxyWrapper to return the constructor function
const mockMakeProxyWrapper = jest.fn((xml) => {
  return mockProxyConstructor;
});

const mockGio = {
  DBus: {
    system: {},
  },
  DBusProxy: {
    makeProxyWrapper: mockMakeProxyWrapper,
  },
};

jest.unstable_mockModule('gi://Gio', () => ({ default: mockGio }));

const { SensorProxyDbus } = await import('../lib/SensorProxyDbus.js');

describe('SensorProxyDbus', () => {
  let dbus;

  beforeEach(() => {
    // Clear only the mock call history, not their implementations
    mockProxy.ClaimLightAsync.mockClear();
    mockProxy.ReleaseLightAsync.mockClear();
    mockProxy.connect.mockClear();
    mockProxy.disconnect.mockClear();
    if (mockProxyConstructor) {
      mockProxyConstructor.mockClear();
      // Restore default implementation for the proxy constructor
      mockProxyConstructor.mockImplementation((bus, busName, objectPath, callback) => {
        process.nextTick(() => callback(mockProxy, null));
      });
    }

    mockProxy.ClaimLightAsync.mockImplementation((callback) => {
      process.nextTick(() => callback(null, null));
    });
    mockProxy.ReleaseLightAsync.mockImplementation((callback) => {
      process.nextTick(() => callback(null, null));
    });
    mockProxy.LightLevel = null;
    mockProxy.HasAmbientLight = null;

    dbus = new SensorProxyDbus();
  });

  afterEach(() => {
    if (dbus) {
      dbus.destroy();
    }
  });

  describe('constructor', () => {
    it('should initialize with null proxy', () => {
      expect(dbus._proxy).toBeNull();
    });
  });

  describe('connect()', () => {
    it('should connect to D-Bus sensor proxy service', async () => {
      await dbus.connect();
      expect(dbus._proxy).not.toBeNull();
    });

    it('should connect to correct D-Bus service and path', async () => {
      await dbus.connect();

      expect(mockProxyConstructor).toHaveBeenCalledWith(
        mockGio.DBus.system,
        'net.hadess.SensorProxy',
        '/net/hadess/SensorProxy',
        expect.any(Function)
      );
    });

    it('should handle connection errors', async () => {
      const mockError = new Error('Connection failed');

      // Mock the constructor to return error on next call
      mockProxyConstructor.mockImplementationOnce((bus, busName, objectPath, callback) => {
        process.nextTick(() => callback(null, mockError));
      });

      await expect(dbus.connect()).rejects.toThrow('Connection failed');
    });
  });

  describe('claimLight()', () => {
    it('should claim light sensor after connection', async () => {
      await dbus.connect();
      await dbus.claimLight();
      expect(mockProxy.ClaimLightAsync).toHaveBeenCalled();
    });

    it('should throw error when not connected', async () => {
      await expect(dbus.claimLight()).rejects.toThrow('D-Bus proxy not connected');
    });

    it('should handle claim light error', async () => {
      await dbus.connect();
      mockProxy.ClaimLightAsync.mockImplementation((callback) => {
        process.nextTick(() => callback(null, new Error('ClaimLight failed')));
      });

      await expect(dbus.claimLight()).rejects.toThrow('ClaimLight failed');
    });
  });

  describe('releaseLight()', () => {
    it('should release light sensor', async () => {
      await dbus.connect();
      await dbus.claimLight();

      dbus.releaseLight();

      expect(mockProxy.ReleaseLightAsync).toHaveBeenCalled();
    });

    it('should handle release when not connected', () => {
      expect(() => dbus.releaseLight()).not.toThrow();
    });

    it('should log error on release failure', async () => {
      await dbus.connect();
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

      mockProxy.ReleaseLightAsync.mockImplementation((callback) => {
        process.nextTick(() => callback(null, new Error('Release failed')));
      });

      dbus.releaseLight();

      // Wait for async callback
      await new Promise((resolve) => process.nextTick(resolve));

      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Failed to release light sensor:',
        expect.any(Error)
      );
      consoleErrorSpy.mockRestore();
    });
  });

  describe('lightLevel', () => {
    it('should return null when not connected', () => {
      const level = dbus.lightLevel;
      expect(level).toBeNull();
    });

    it('should return current light level from proxy property', async () => {
      await dbus.connect();
      mockProxy.LightLevel = 123.5;

      const level = dbus.lightLevel;
      expect(level).toBe(123.5);
    });

    it('should return null when light level property not available', async () => {
      await dbus.connect();
      mockProxy.LightLevel = null;

      const level = dbus.lightLevel;
      expect(level).toBeNull();
    });

    it('should handle errors when accessing property', async () => {
      await dbus.connect();
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

      Object.defineProperty(mockProxy, 'LightLevel', {
        get: () => {
          throw new Error('Property access failed');
        },
        configurable: true,
      });

      const level = dbus.lightLevel;

      expect(level).toBeNull();
      expect(consoleErrorSpy).toHaveBeenCalled();
      consoleErrorSpy.mockRestore();

      // Restore property
      delete mockProxy.LightLevel;
      mockProxy.LightLevel = null;
    });
  });

  describe('hasAmbientLight', () => {
    it('should return null when not connected', () => {
      const hasLight = dbus.hasAmbientLight;
      expect(hasLight).toBeNull();
    });

    it('should return true when ambient light sensor is available', async () => {
      await dbus.connect();
      mockProxy.HasAmbientLight = true;

      const hasLight = dbus.hasAmbientLight;
      expect(hasLight).toBe(true);
    });

    it('should return false when ambient light sensor is not available', async () => {
      await dbus.connect();
      mockProxy.HasAmbientLight = false;

      const hasLight = dbus.hasAmbientLight;
      expect(hasLight).toBe(false);
    });

    it('should return null when property not available', async () => {
      await dbus.connect();
      mockProxy.HasAmbientLight = null;

      const hasLight = dbus.hasAmbientLight;
      expect(hasLight).toBeNull();
    });
  });

  describe('onPropertiesChanged()', () => {
    beforeEach(async () => {
      await dbus.connect();
    });

    it('should register property change listener', () => {
      const callback = jest.fn();
      const signalId = dbus.onPropertiesChanged(callback);

      expect(mockProxy.connect).toHaveBeenCalledWith('g-properties-changed', callback);
      expect(signalId).toBe(1);
    });

    it('should throw error when not connected', () => {
      dbus.destroy();
      expect(() => dbus.onPropertiesChanged(() => { })).toThrow('D-Bus proxy not connected');
    });
  });

  describe('disconnectListener()', () => {
    beforeEach(async () => {
      await dbus.connect();
    });

    it('should disconnect signal handler', () => {
      const callback = jest.fn();
      const signalId = dbus.onPropertiesChanged(callback);

      dbus.disconnectListener(signalId);

      expect(mockProxy.disconnect).toHaveBeenCalledWith(signalId);
    });

    it('should handle disconnect when not connected', () => {
      dbus.destroy();
      expect(() => dbus.disconnectListener(123)).not.toThrow();
    });

    it('should handle disconnect with null signalId', () => {
      expect(() => dbus.disconnectListener(null)).not.toThrow();
    });
  });

  describe('destroy()', () => {
    it('should clear proxy reference', async () => {
      await dbus.connect();
      expect(dbus._proxy).not.toBeNull();

      dbus.destroy();
      expect(dbus._proxy).toBeNull();
    });

    it('should handle destroy when not connected', () => {
      expect(() => dbus.destroy()).not.toThrow();
    });

    it('should handle multiple destroy calls', async () => {
      await dbus.connect();
      dbus.destroy();
      expect(() => dbus.destroy()).not.toThrow();
    });
  });

  describe('integration scenarios', () => {
    it('should handle complete lifecycle', async () => {
      // Connect
      await dbus.connect();

      // Claim sensor
      await dbus.claimLight();
      expect(mockProxy.ClaimLightAsync).toHaveBeenCalled();

      // Get light level
      mockProxy.LightLevel = 150.0;
      expect(dbus.lightLevel).toBe(150.0);

      // Get sensor availability
      mockProxy.HasAmbientLight = true;
      expect(dbus.hasAmbientLight).toBe(true);

      // Subscribe to changes
      const callback = jest.fn();
      const signalId = dbus.onPropertiesChanged(callback);
      expect(signalId).toBe(1);

      // Disconnect listener
      dbus.disconnectListener(signalId);
      expect(mockProxy.disconnect).toHaveBeenCalledWith(signalId);

      // Release sensor
      dbus.releaseLight();
      expect(mockProxy.ReleaseLightAsync).toHaveBeenCalled();

      // Destroy
      dbus.destroy();
      expect(dbus._proxy).toBeNull();
    });
  });
});
